# 编程思想

1. 循环的是实现方式可以通过递归也可以通过for/while实现。例如数据结构中树的定义。<br>在递归过程中，一般需要先进行递归条件判断，然后再对当前条件计算判断。<br>在循环过程中，退出条件的设定是很关键的。一定要覆盖，避免死递归

   ```java
   /*
    * (递归实现)查找"二叉树x"中键值为key的节点
    */
   private BSTNode<T> search(BSTNode<T> x, T key) {
       if (x==null)
           return x;
   
       int cmp = key.compareTo(x.key);
       if (cmp < 0)
           return search(x.left, key);
       else if (cmp > 0)
           return search(x.right, key);
       else
           return x;
   }
   
   public BSTNode<T> search(T key) {
       return search(mRoot, key);
   }
   
   ```

2. 移位操作完成运算

   对于一些实时性要求非常高的功能，使用移位，与，或，掩码。

3. 

# 事件思想

文件读写导出（Redis文件 文件导出）

- 文件名称，路径
- 文件导出内容格式（是否压缩）
- 多次重复频繁写，策略
- 文件导出过程并发问题
- 文件异常处理

# 设计思想

## 队列节点的设计

内部类，通过指针/引用方式使用

## 服务冗余设计

- 服务提供冗余-高可用。

  正常的负载均衡，读写分离

  不正常的主从切换。灾备

- 服务保障冗余-高可靠

## 数据冗余设计

- 数据一致性问题
- 数据同步问题
- 数据源切换问题

## 统一接口封装设计

话说都是层层封装，一层套一层，还是封装带来如下优势

- 接口参数类型本土化化
- 增加额外有用信息

# 接口幂等设计

> 程序大致分为就是操作模型和数据模型。数据模型狭义上是指能沉淀下来的数据即MySQL
>
> 在HTTP/1.1中 对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用
>
> 一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。
>
> 防范切入点：1. 对多次进行限制。2. 对沉淀结果进行判断保护。3. 从定义上缩小操作范围影响（缩小到唯一序列号）

## 数据库层面（狭义）

> 数据库层面主要分类处理查，改，增，删。

通用：select for update

改：乐观锁，即版本号或者时间戳。状态机，即定义不同状态条件（大小关系）

增：全局流水表

## 分布式锁

> 分布式应用

Token机制，这个感觉主要是限流的意义

## 业务逻辑上

下游传递唯一序列号，对于这笔序列号做唯一逻辑处理，存储可用redis或者MySQL