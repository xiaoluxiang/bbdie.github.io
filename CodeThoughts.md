# 编程思想

1. 循环的是实现方式可以通过递归也可以通过for/while实现。例如数据结构中树的定义。<br>在递归过程中，一般需要先进行递归条件判断，然后再对当前条件计算判断。<br>在循环过程中，退出条件的设定是很关键的。一定要覆盖，避免死递归

   ```java
   /*
    * (递归实现)查找"二叉树x"中键值为key的节点
    */
   private BSTNode<T> search(BSTNode<T> x, T key) {
       if (x==null)
           return x;
   
       int cmp = key.compareTo(x.key);
       if (cmp < 0)
           return search(x.left, key);
       else if (cmp > 0)
           return search(x.right, key);
       else
           return x;
   }
   
   public BSTNode<T> search(T key) {
       return search(mRoot, key);
   }
   
   ```

2. 移位操作完成运算

   对于一些实时性要求非常高的功能，使用移位，与，或，掩码。



# 优化思想

锁：降低锁的粒度和锁的持有时间

吞吐率：提高发送/请求频率，压缩请求体，设置优先级

# 事件思想

文件读写导出（Redis文件 文件导出）

- 文件名称，路径
- 文件导出内容格式（是否压缩）
- 多次重复频繁写，策略
- 文件导出过程并发问题
- 文件异常处理

# 设计思想

> 任何基础组件都需要服务业务场景

## 队列节点的设计

内部类，通过指针/引用方式使用

## 服务冗余设计

- 服务提供冗余-高可用。

  正常的负载均衡，读写分离

  不正常的主从切换。灾备

- 服务保障冗余-高可靠

## 数据冗余设计

- 数据一致性问题
- 数据同步问题
- 数据源切换问题

## 统一接口封装设计

话说都是层层封装，一层套一层，还是封装带来如下优势

- 接口参数类型本土化化
- 增加额外有用信息

# 接口幂等设计

> 程序大致分为就是操作模型和数据模型。数据模型狭义上是指能沉淀下来的数据即MySQL
>
> 在HTTP/1.1中 对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用
>
> 一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。
>
> 防范切入点：1. 对多次进行限制。2. 对沉淀结果进行判断保护。3. 从定义上缩小操作范围影响（缩小到唯一序列号）

## 数据库层面（狭义）

> 数据库层面主要分类处理查，改，增，删。

通用：select for update

改：乐观锁，即版本号或者时间戳。状态机，即定义不同状态条件（大小关系）

增：全局流水表

## 分布式锁

> 分布式应用

Token机制，这个感觉主要是限流的意义

## 业务逻辑上

下游传递唯一序列号，对于这笔序列号做唯一逻辑处理，存储可用redis或者MySQL



# 中间层

在计算机领域中，一般通过增加中间层都能解决很多问题。主要解决映射关系



# 消息队列设计精要

> 基于消息的通讯模式，从关注处理到关注通知。解放上下游
>
> 解耦->广播->最终一致性->错峰与流控

参考地址：[美团：消息队列设计精要](https://tech.meituan.com/2016/07/01/mq-design.html)

## 解耦

解耦是为了降低某节点非必要甚至是不合理的责任任务。同时也可以减少非核心流程的不确定性，对核心流程的安全高效的影响

## 广播

消息队列的基本功能，谁关心谁接入。对于生产者知需要关系消息推送，消费者只关心消费的消费，最大程度减少链条

## 最终一致性

在CAP原则中，在满足AP（即可用性和分区性）上无法一定能做到一致性，但是可以做到最终一致性，这个一致性是允许存在时间差的。在跨VM的一致性问题中主要存在俩种解决方案

- 强一致性，在分布式事务中，通过RPC做到强一致性有较大难度及较高成本
- 最终一致性，在分布式事务中，通过记录和补偿的方式，预先记录所有的不确定的事情，然后执行后根据结果重放或者其他，去重可以通过版本机状态来处理。

## 错峰和流控

上下游对于数据的处理能力是不同的，如果不引入第三方存储，则可采用协商，滑动窗口的方式来解决问题，双方都需要建立存储，并开发一套逻辑来处理

## 队列的基本功能

RPC通讯协议<br>支持生产者和消费者的消息投递与消费，涉及到服务发现，负责均衡，通讯协议，序列化等等。可以使用现成轮子

高可用<br>消息有效投递有效存储和有效分发。RPC的高可用和存储的高可用

承载消息堆积的能力<br>持久化<->非持久化（日志收集可以不用持久化），文件存储的子系统速度：文件系统>分布式KV（持久化）>分布式文件系统>数据库，可靠性相反

消费关系<br>单播与广播的区别，一般来说都是组间广播和组内单播。初次之外，还需要做到发送关系的维护（集和权重的变化）和发送关系的变更（上下线）

## 队列的高级功能

最终一致性（可靠投递）

- producer往broker发送消息之前，需要做一次落地。
- 请求到server后，server确保数据落地后再告诉客户端发送成功。
- 支持广播的消息队列需要对每个待发送的endpoint，持久化一个发送状态，直到所有endpoint状态都OK才可删除消息。